"""Business models (simple and pedagogical)."""
import secrets
import string

from django.conf import settings
from django.contrib.auth.hashers import check_password, make_password
from django.core.exceptions import ValidationError
from django.db import models
from django.utils import timezone

from .validators import validate_upload_extension, validate_upload_size


class MeterPoint(models.Model):
    """Supply point used for invitation-based onboarding."""

    ean = models.CharField(max_length=30, unique=True)
    address_line1 = models.CharField(max_length=120)
    address_line2 = models.CharField(max_length=120, blank=True)
    postal_code = models.CharField(max_length=10)
    city = models.CharField(max_length=80)
    country = models.CharField(max_length=2, default="BE")
    holder_firstname = models.CharField(max_length=80)
    holder_lastname = models.CharField(max_length=80)

    class Meta:
        ordering = ["ean"]

    def __str__(self) -> str:
        return self.ean

    def save(self, *args, **kwargs):
        if self.pk:
            previous_ean = MeterPoint.objects.filter(pk=self.pk).values_list("ean", flat=True).first()
            if previous_ean and previous_ean != self.ean:
                raise ValidationError("Le code EAN ne peut pas etre modifie.")
        super().save(*args, **kwargs)

    @property
    def full_address(self) -> str:
        line2 = f", {self.address_line2}" if self.address_line2 else ""
        return f"{self.address_line1}{line2}, {self.postal_code} {self.city}, {self.country}"

    @property
    def holder_full_name(self) -> str:
        return f"{self.holder_firstname} {self.holder_lastname}".strip()


class MeterPointHistory(models.Model):
    """Monthly historical data attached to a meter point before online registration."""

    meter_point = models.ForeignKey(MeterPoint, on_delete=models.CASCADE, related_name="history_items")
    period_start = models.DateField()
    period_end = models.DateField()
    reading_date = models.DateField()
    consumption_kwh = models.PositiveIntegerField()
    amount_eur = models.DecimalField(max_digits=8, decimal_places=2)

    class Meta:
        ordering = ["period_start"]
        unique_together = [("meter_point", "period_start")]

    def __str__(self) -> str:
        return f"{self.meter_point.ean} {self.period_start:%Y-%m}"


class Contract(models.Model):
    """Energy supply contract linked to a user."""

    STATUS_ACTIVE = "active"
    STATUS_SUSPENDED = "suspended"
    STATUS_CLOSED = "closed"

    STATUS_CHOICES = [
        (STATUS_ACTIVE, "Actif"),
        (STATUS_SUSPENDED, "Suspendu"),
        (STATUS_CLOSED, "Clôturé"),
    ]

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    meter_point = models.ForeignKey(MeterPoint, on_delete=models.SET_NULL, null=True, blank=True)
    reference = models.CharField(max_length=50, unique=True)
    start_date = models.DateField()
    plan_name = models.CharField(max_length=100)
    supply_address = models.CharField(max_length=200)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=STATUS_ACTIVE)

    def __str__(self) -> str:
        return f"{self.reference}"


class Invitation(models.Model):
    """Invitation generated by admin for self-registration."""

    meter_point = models.ForeignKey(MeterPoint, on_delete=models.CASCADE, related_name="invitations")
    secret_code_hash = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()
    used_at = models.DateTimeField(null=True, blank=True)
    used_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="used_invitations",
    )
    failed_attempts = models.PositiveSmallIntegerField(default=0)
    locked_until = models.DateTimeField(null=True, blank=True)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return f"Invitation {self.meter_point.ean} ({self.created_at:%Y-%m-%d})"

    @staticmethod
    def generate_secret_code() -> str:
        alphabet = string.ascii_uppercase + string.digits
        left = "".join(secrets.choice(alphabet) for _ in range(4))
        right = "".join(secrets.choice(alphabet) for _ in range(4))
        return f"{left}-{right}"

    @classmethod
    def create_with_secret(cls, meter_point, expires_at):
        secret_code = cls.generate_secret_code()
        invitation = cls.objects.create(
            meter_point=meter_point,
            secret_code_hash=make_password(secret_code),
            expires_at=expires_at,
        )
        return invitation, secret_code

    @property
    def is_locked(self) -> bool:
        return bool(self.locked_until and self.locked_until > timezone.now())

    @property
    def is_valid(self) -> bool:
        now = timezone.now()
        return (
            self.used_by is None
            and
            self.used_at is None
            and self.expires_at > now
            and (self.locked_until is None or self.locked_until <= now)
        )

    def check_secret_code(self, raw_secret_code: str) -> bool:
        return check_password(raw_secret_code, self.secret_code_hash)

    def register_failed_attempt(self):
        self.failed_attempts += 1
        if self.failed_attempts >= 5:
            self.locked_until = timezone.now() + timezone.timedelta(minutes=15)
            self.failed_attempts = 0
        self.save(update_fields=["failed_attempts", "locked_until"])

    def reset_failed_attempts(self):
        self.failed_attempts = 0
        self.locked_until = None
        self.save(update_fields=["failed_attempts", "locked_until"])


class Invoice(models.Model):
    """Customer invoice linked to a user (no PDF file)."""

    STATUS_DUE = "due"
    STATUS_PAID = "paid"
    STATUS_CANCELLED = "cancelled"

    STATUS_CHOICES = [
        (STATUS_DUE, "À payer"),
        (STATUS_PAID, "Payée"),
        (STATUS_CANCELLED, "Annulée"),
    ]

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    reference = models.CharField(max_length=50)
    period_start = models.DateField()
    period_end = models.DateField()
    issue_date = models.DateField()
    amount_eur = models.DecimalField(max_digits=8, decimal_places=2)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=STATUS_DUE)
    pdf_file = models.FileField(
        upload_to="invoices/",
        blank=True,
        null=True,
        validators=[validate_upload_extension, validate_upload_size],
    )

    class Meta:
        ordering = ["-issue_date"]

    def __str__(self) -> str:
        return f"{self.reference}"


class MeterReading(models.Model):
    """Meter reading linked to a user."""

    STATUS_SUBMITTED = "submitted"
    STATUS_VALIDATED = "validated"
    STATUS_REJECTED = "rejected"

    STATUS_CHOICES = [
        (STATUS_SUBMITTED, "En cours de validation"),
        (STATUS_VALIDATED, "Validé"),
        (STATUS_REJECTED, "Refusé"),
    ]

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    reading_date = models.DateField()
    value_kwh = models.PositiveIntegerField()
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=STATUS_SUBMITTED)
    note = models.CharField(max_length=255, blank=True)

    class Meta:
        ordering = ["-reading_date"]

    def __str__(self) -> str:
        return f"{self.reading_date}"


class SupportRequest(models.Model):
    """Support request linked to a user."""

    STATUS_OPEN = "open"
    STATUS_IN_PROGRESS = "in_progress"
    STATUS_CLOSED = "closed"

    STATUS_CHOICES = [
        (STATUS_OPEN, "Ouverte"),
        (STATUS_IN_PROGRESS, "En cours"),
        (STATUS_CLOSED, "Clôturée"),
    ]

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    subject = models.CharField(max_length=120)
    message = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=STATUS_OPEN)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return self.subject


class Domiciliation(models.Model):
    """Direct debit activation request linked to a user."""

    STATUS_PENDING = "pending"
    STATUS_ACTIVE = "active"
    STATUS_REJECTED = "rejected"

    STATUS_CHOICES = [
        (STATUS_PENDING, "En attente"),
        (STATUS_ACTIVE, "Active"),
        (STATUS_REJECTED, "Refusée"),
    ]

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=STATUS_PENDING)
    document = models.FileField(
        upload_to="domiciliation/",
        validators=[validate_upload_extension, validate_upload_size],
    )

    class Meta:
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return f"Domiciliation {self.user}"


class Attachment(models.Model):
    """Attachment linked to a support request (1-n)."""

    support_request = models.ForeignKey(SupportRequest, on_delete=models.CASCADE, related_name="attachments")
    file = models.FileField(
        upload_to="support_attachments/",
        validators=[validate_upload_extension, validate_upload_size],
    )
    uploaded_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["-uploaded_at"]

    def __str__(self) -> str:
        return f"Piece jointe {self.id}"


class CustomerProfile(models.Model):
    """Customer profile linked to a user (administrative data)."""

    CONTACT_EMAIL = "email"
    CONTACT_PHONE = "phone"

    CONTACT_CHOICES = [
        (CONTACT_EMAIL, "E-mail"),
        (CONTACT_PHONE, "Téléphone"),
    ]

    LANG_FR = "fr"
    LANG_NL = "nl"
    LANG_EN = "en"

    LANGUAGE_CHOICES = [
        (LANG_FR, "Français"),
        (LANG_NL, "Nederlands"),
        (LANG_EN, "English"),
    ]

    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    customer_ref = models.CharField(max_length=30, unique=True)
    ean = models.CharField(max_length=30, unique=True)
    supply_address_street = models.CharField(max_length=120)
    supply_address_number = models.CharField(max_length=20)
    supply_address_postal_code = models.CharField(max_length=10)
    supply_address_city = models.CharField(max_length=80)

    billing_address_street = models.CharField(max_length=120, blank=True)
    billing_address_number = models.CharField(max_length=20, blank=True)
    billing_address_postal_code = models.CharField(max_length=10, blank=True)
    billing_address_city = models.CharField(max_length=80, blank=True)
    phone = models.CharField(max_length=30, blank=True)
    meter_serial = models.CharField(max_length=30, blank=True)
    preferred_contact = models.CharField(max_length=10, choices=CONTACT_CHOICES, default=CONTACT_EMAIL)
    language = models.CharField(max_length=5, choices=LANGUAGE_CHOICES, default=LANG_FR)
    notes_admin = models.TextField(blank=True)

    def __str__(self) -> str:
        return f"{self.customer_ref}"
